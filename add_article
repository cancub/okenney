#! /usr/bin/env python

import copy
import cv2
import datetime
import os
import re
import sys

from app import db
from app.mod_articles.models import Article
from app.mod_articles import IMAGES_DIR, ARTICLES_DIR

'''
TODO:
- Use relational database for categories
- use argparse
'''

CATEGORIES = ['about', 'ideas', 'politics', 'philosophy', 'projects']
BIG_IMAGE_HEIGHT = 600
BIG_IMAGE_WIDTH = 1000
SMALL_IMAGE_SCALE = 0.15
IMAGE_NAME = 'principal'
IMAGE_BIG_NAME = IMAGE_NAME + '-gd.png'
IMAGE_SMALL_NAME = IMAGE_NAME + '-pt.png'

def build_filename(path):
    # Get the contents of the file.
    with open(path, 'r') as F:
        contents = F.read()

    # Retrieve the title, using what we know about how the file must be
    # structured.
    p = re.compile(r'{%\s*macro titre\(\)\s*%}\s*(.*)\s*{%\s*endmacro\s*%}')
    title = p.search(contents).groups(0)[0].lower()

    # Remove articles ,conjunctions, non-letter characters and convert spaces to
    # dash
    letter_neg_lookbehind = '(?<!\w)'
    letter_neg_lookahead = '(?!\w)'
    title = re.sub(
        ('{0}[tT]he{1}|{0}[oO]f{1}|{0}[aA]nd{1}|{0}a{1}|{0}[Aa]{1}|'
         '[$-/:-?{{-~!"^_`\[\]]').format(
            letter_neg_lookbehind,
            letter_neg_lookahead,
        ),
        '',
        title
    )

    # Remove the spaces from the end.
    title = title.rstrip()

    # Locate the individual words remaining
    p = re.compile(r'\w+')
    title_words = p.findall(title)

    # Crop it down to the first 5 words or whatever number of words there are,
    # whichever is smaller
    title_length = min(5, len(title_words))

    return '-'.join(title_words[:title_length])

def get_crop_dims(actual_dim, desired_dim):
    to_crop = (actual_dim - desired_dim) / 2

    # No need to crop if we're already at the right dimension.
    if to_crop == 0:
        return 0, actual_dim

    int_crop = int(to_crop)
    if int_crop == to_crop:
        # We're dealing with a whole number, which means we can crop the same
        # amount from each side.
        crop_high = crop_low = int_crop
    else:
        # We're dealing with a fraction. Round down for the high and round
        # up for the low.
        crop_high = int_crop
        crop_low = int_crop + 1

    return crop_low, actual_dim - crop_high

def build_images(path):
    image_big = cv2.imread(path)

    height, width, _ = image_big.shape

    # Scale dimension closest to the desired aspect ratio of 1000 x 600
    height_scale = BIG_IMAGE_HEIGHT / height
    width_scale = BIG_IMAGE_WIDTH / width

    if width_scale < height_scale:
        # The height is closer than the width to its respective dimension in
        # the desired aspect ratio. So it's better to scale the height to
        # the desired height and crop the width.
        dx = int(width * height_scale)
        dy = BIG_IMAGE_HEIGHT
    else:
        # The opposite is true.
        dx = BIG_IMAGE_WIDTH
        dy = int(height * width_scale)

    # Scale the image
    image_big = cv2.resize(image_big, (dx, dy))

    # Prepare for the crop. Only one of these dimentions witll be changed.
    height_crop_low = 0
    height_crop_high = image_big.shape[0]
    width_crop_low = 0
    width_crop_high = image_big.shape[1]

    if dy == BIG_IMAGE_HEIGHT:
        # We scaled to the height, so we need to crop to the width.
        width_crop_low, width_crop_high = get_crop_dims(
            width_crop_high,
            BIG_IMAGE_WIDTH,
        )
    else:
        # We scaled to the width, so we need to crop to the height.
        height_crop_low, height_crop_high = get_crop_dims(
            height_crop_high,
            BIG_IMAGE_WIDTH,
        )

    # Crop and center to this aspect ratio.
    image_big = image_big[
        height_crop_low:height_crop_high,
        width_crop_low:width_crop_high,
        :
    ]

    # Make a copy and scale it down.
    image_small = cv2.resize(
        copy.copy(image_big),
        (0, 0),
        fx=SMALL_IMAGE_SCALE,
        fy=SMALL_IMAGE_SCALE,
    )

    return image_big, image_small

def build_paths(category, title):
    # make the directories that the files will be stored in an all intermediary
    # directories.
    images_dir = os.path.join(IMAGES_DIR, category, title)
    article_dir = os.path.join(ARTICLES_DIR, category)
    for directory in (images_dir, article_dir):
        try:
            os.makedirs(directory)
        except FileExistsError:
            pass

    return os.path.join(article_dir, title + '.html'), images_dir


text_path = os.path.abspath(sys.argv[1])
image_path = sys.argv[2]
category = sys.argv[3]

if not os.path.exists(text_path):
    raise Exception('No text file exists at {}'.format(text_path))

if category not in CATEGORIES:
    raise Exception('Unknown category "{}"'.format(category))

if not os.path.exists(image_path):
    raise Exception('No image file exists at {}'.format(image_path))

# Locate the title within the file.
title = build_filename(text_path)

# Load the images
image_big, image_small = build_images(image_path)

now = datetime.datetime.now()

# Build the directory for both images and templates.
article_path, images_dir = build_paths(category, title)

# Store the article in the specified directory under the title.
if os.path.exists(article_path):
    raise FileExistsError('We already wrote an article with that name')
os.rename(text_path, article_path)

# Store the large and small image files in the images directory.
cv2.imwrite(os.path.join(images_dir, IMAGE_BIG_NAME), image_big)
cv2.imwrite(os.path.join(images_dir, IMAGE_SMALL_NAME), image_small)

# Store this information in the database
db.session.add(Article(name=title, category=category, dtime=now))
db.session.commit()

# Print out the path the images dir into which we need to dump all of the
# images for the article.
print(images_dir)
